Index: intern/cycles/bvh/bvh.cpp
===================================================================
--- intern/cycles/bvh/bvh.cpp (revision 0)
+++ intern/cycles/bvh/bvh.cpp (working copy)
@@ -81,7 +81,7 @@ void BVH::build(Progress& progress)
 	                   pack.prim_type,
 	                   pack.prim_index,
 	                   pack.prim_object,
-	                   pack.prim_time,
+//	                   pack.prim_time,
 	                   params,
 	                   progress);
 	BVHNode *root = bvh_build.run();
@@ -257,9 +257,9 @@ void BVH::pack_instances(size_t nodes_size, size_t leaf_nodes_size)
 	pack.leaf_nodes.resize(leaf_nodes_size);
 	pack.object_node.resize(objects.size());
 
-	if(params.num_motion_curve_steps > 0 || params.num_motion_triangle_steps > 0) {
-		pack.prim_time.resize(prim_index_size);
-	}
+//	if(params.num_motion_curve_steps > 0 || params.num_motion_triangle_steps > 0) {
+//		pack.prim_time.resize(prim_index_size);
+//	}
 
 	int *pack_prim_index = (pack.prim_index.size())? &pack.prim_index[0]: NULL;
 	int *pack_prim_type = (pack.prim_type.size())? &pack.prim_type[0]: NULL;
@@ -269,7 +269,7 @@ void BVH::pack_instances(size_t nodes_size, size_t leaf_nodes_size)
 	uint *pack_prim_tri_index = (pack.prim_tri_index.size())? &pack.prim_tri_index[0]: NULL;
 	int4 *pack_nodes = (pack.nodes.size())? &pack.nodes[0]: NULL;
 	int4 *pack_leaf_nodes = (pack.leaf_nodes.size())? &pack.leaf_nodes[0]: NULL;
-	float2 *pack_prim_time = (pack.prim_time.size())? &pack.prim_time[0]: NULL;
+//	float2 *pack_prim_time = (pack.prim_time.size())? &pack.prim_time[0]: NULL;
 
 	/* merge */
 	foreach(Object *ob, objects) {
@@ -315,7 +315,7 @@ void BVH::pack_instances(size_t nodes_size, size_t leaf_nodes_size)
 			int *bvh_prim_type = &bvh->pack.prim_type[0];
 			uint *bvh_prim_visibility = &bvh->pack.prim_visibility[0];
 			uint *bvh_prim_tri_index = &bvh->pack.prim_tri_index[0];
-			float2 *bvh_prim_time = bvh->pack.prim_time.size()? &bvh->pack.prim_time[0]: NULL;
+//			float2 *bvh_prim_time = bvh->pack.prim_time.size()? &bvh->pack.prim_time[0]: NULL;
 
 			for(size_t i = 0; i < bvh_prim_index_size; i++) {
 				if(bvh->pack.prim_type[i] & PRIMITIVE_ALL_CURVE) {
@@ -331,9 +331,9 @@ void BVH::pack_instances(size_t nodes_size, size_t leaf_nodes_size)
 				pack_prim_type[pack_prim_index_offset] = bvh_prim_type[i];
 				pack_prim_visibility[pack_prim_index_offset] = bvh_prim_visibility[i];
 				pack_prim_object[pack_prim_index_offset] = 0;  // unused for instances
-				if(bvh_prim_time != NULL) {
-					pack_prim_time[pack_prim_index_offset] = bvh_prim_time[i];
-				}
+//				if(bvh_prim_time != NULL) {
+//					pack_prim_time[pack_prim_index_offset] = bvh_prim_time[i];
+//				}
 				pack_prim_index_offset++;
 			}
 		}
Index: intern/cycles/bvh/bvh.h
===================================================================
--- intern/cycles/bvh/bvh.h (revision 0)
+++ intern/cycles/bvh/bvh.h (working copy)
@@ -69,7 +69,7 @@ struct PackedBVH {
 	/* mapping from BVH primitive index, to the object id of that primitive. */
 	array<int> prim_object;
 	/* Time range of BVH primitive. */
-	array<float2> prim_time;
+//	array<float2> prim_time;
 
 	/* index of the root node. */
 	int root_index;
Index: intern/cycles/bvh/bvh_build.cpp
===================================================================
--- intern/cycles/bvh/bvh_build.cpp (revision 0)
+++ intern/cycles/bvh/bvh_build.cpp (working copy)
@@ -93,14 +93,14 @@ BVHBuild::BVHBuild(const vector<Object*>& objects_,
                    array<int>& prim_type_,
                    array<int>& prim_index_,
                    array<int>& prim_object_,
-                   array<float2>& prim_time_,
+//                   array<float2>& prim_time_,
                    const BVHParams& params_,
                    Progress& progress_)
  : objects(objects_),
    prim_type(prim_type_),
    prim_index(prim_index_),
    prim_object(prim_object_),
-   prim_time(prim_time_),
+//   prim_time(prim_time_),
    params(params_),
    progress(progress_),
    progress_start_time(0.0),
@@ -480,12 +480,12 @@ BVHNode* BVHBuild::run()
 	prim_type.resize(references.size());
 	prim_index.resize(references.size());
 	prim_object.resize(references.size());
-	if(need_prim_time) {
-		prim_time.resize(references.size());
-	}
-	else {
-		prim_time.resize(0);
-	}
+//	if(need_prim_time) {
+//		prim_time.resize(references.size());
+//	}
+//	else {
+//		prim_time.resize(0);
+//	}
 
 	/* build recursively */
 	BVHNode *rootnode;
@@ -860,9 +860,9 @@ BVHNode *BVHBuild::create_object_leaf_nodes(const BVHReference *ref, int start,
 		prim_type[start] = ref->prim_type();
 		prim_index[start] = ref->prim_index();
 		prim_object[start] = ref->prim_object();
-		if(need_prim_time) {
-			prim_time[start] = make_float2(ref->time_from(), ref->time_to());
-		}
+//		if(need_prim_time) {
+//			prim_time[start] = make_float2(ref->time_from(), ref->time_to());
+//		}
 
 		uint visibility = objects[ref->prim_object()]->visibility;
 		BVHNode *leaf_node =  new LeafNode(ref->bounds(), visibility, start, start+1);
@@ -910,7 +910,7 @@ BVHNode* BVHBuild::create_leaf_node(const BVHRange& range,
 	vector<int, LeafStackAllocator> p_type[PRIMITIVE_NUM_TOTAL];
 	vector<int, LeafStackAllocator> p_index[PRIMITIVE_NUM_TOTAL];
 	vector<int, LeafStackAllocator> p_object[PRIMITIVE_NUM_TOTAL];
-	vector<float2, LeafStackAllocator> p_time[PRIMITIVE_NUM_TOTAL];
+//	vector<float2, LeafStackAllocator> p_time[PRIMITIVE_NUM_TOTAL];
 	vector<BVHReference, LeafReferenceStackAllocator> p_ref[PRIMITIVE_NUM_TOTAL];
 
 	/* TODO(sergey): In theory we should be able to store references. */
@@ -933,8 +933,8 @@ BVHNode* BVHBuild::create_leaf_node(const BVHRange& range,
 			p_type[type_index].push_back(ref.prim_type());
 			p_index[type_index].push_back(ref.prim_index());
 			p_object[type_index].push_back(ref.prim_object());
-			p_time[type_index].push_back(make_float2(ref.time_from(),
-			                                         ref.time_to()));
+//			p_time[type_index].push_back(make_float2(ref.time_from(),
+//			                                         ref.time_to()));
 
 			bounds[type_index].grow(ref.bounds());
 			visibility[type_index] |= objects[ref.prim_object()]->visibility;
@@ -964,13 +964,13 @@ BVHNode* BVHBuild::create_leaf_node(const BVHRange& range,
 	vector<int, LeafStackAllocator> local_prim_type,
 	                                local_prim_index,
 	                                local_prim_object;
-	vector<float2, LeafStackAllocator> local_prim_time;
+//	vector<float2, LeafStackAllocator> local_prim_time;
 	local_prim_type.resize(num_new_prims);
 	local_prim_index.resize(num_new_prims);
 	local_prim_object.resize(num_new_prims);
-	if(need_prim_time) {
-		local_prim_time.resize(num_new_prims);
-	}
+//	if(need_prim_time) {
+//		local_prim_time.resize(num_new_prims);
+//	}
 	for(int i = 0; i < PRIMITIVE_NUM_TOTAL; ++i) {
 		int num = (int)p_type[i].size();
 		if(num != 0) {
@@ -983,9 +983,9 @@ BVHNode* BVHBuild::create_leaf_node(const BVHRange& range,
 				local_prim_type[index] = p_type[i][j];
 				local_prim_index[index] = p_index[i][j];
 				local_prim_object[index] = p_object[i][j];
-				if(need_prim_time) {
-					local_prim_time[index] = p_time[i][j];
-				}
+//				if(need_prim_time) {
+//					local_prim_time[index] = p_time[i][j];
+//				}
 				if(params.use_unaligned_nodes && !alignment_found) {
 					alignment_found =
 						unaligned_heuristic.compute_aligned_space(p_ref[i][j],
@@ -1052,17 +1052,17 @@ BVHNode* BVHBuild::create_leaf_node(const BVHRange& range,
 				prim_type.reserve(reserve);
 				prim_index.reserve(reserve);
 				prim_object.reserve(reserve);
-				if(need_prim_time) {
-					prim_time.reserve(reserve);
-				}
+//				if(need_prim_time) {
+//					prim_time.reserve(reserve);
+//				}
 			}
 
 			prim_type.resize(range_end);
 			prim_index.resize(range_end);
 			prim_object.resize(range_end);
-			if(need_prim_time) {
-				prim_time.resize(range_end);
-			}
+//			if(need_prim_time) {
+//				prim_time.resize(range_end);
+//			}
 		}
 		spatial_spin_lock.unlock();
 
@@ -1071,9 +1071,9 @@ BVHNode* BVHBuild::create_leaf_node(const BVHRange& range,
 			memcpy(&prim_type[start_index], &local_prim_type[0], new_leaf_data_size);
 			memcpy(&prim_index[start_index], &local_prim_index[0], new_leaf_data_size);
 			memcpy(&prim_object[start_index], &local_prim_object[0], new_leaf_data_size);
-			if(need_prim_time) {
-				memcpy(&prim_time[start_index], &local_prim_time[0], sizeof(float2)*num_new_leaf_data);
-			}
+//			if(need_prim_time) {
+//				memcpy(&prim_time[start_index], &local_prim_time[0], sizeof(float2)*num_new_leaf_data);
+//			}
 		}
 	}
 	else {
@@ -1086,9 +1086,9 @@ BVHNode* BVHBuild::create_leaf_node(const BVHRange& range,
 			memcpy(&prim_type[start_index], &local_prim_type[0], new_leaf_data_size);
 			memcpy(&prim_index[start_index], &local_prim_index[0], new_leaf_data_size);
 			memcpy(&prim_object[start_index], &local_prim_object[0], new_leaf_data_size);
-			if(need_prim_time) {
-				memcpy(&prim_time[start_index], &local_prim_time[0], sizeof(float2)*num_new_leaf_data);
-			}
+//			if(need_prim_time) {
+//				memcpy(&prim_time[start_index], &local_prim_time[0], sizeof(float2)*num_new_leaf_data);
+//			}
 		}
 	}
 
Index: intern/cycles/bvh/bvh_build.h
===================================================================
--- intern/cycles/bvh/bvh_build.h (revision 0)
+++ intern/cycles/bvh/bvh_build.h (working copy)
@@ -48,7 +48,7 @@ public:
 	         array<int>& prim_type,
 	         array<int>& prim_index,
 	         array<int>& prim_object,
-	         array<float2>& prim_time,
+//	         array<float2>& prim_time,
 	         const BVHParams& params,
 	         Progress& progress);
 	~BVHBuild();
@@ -113,7 +113,7 @@ protected:
 	array<int>& prim_type;
 	array<int>& prim_index;
 	array<int>& prim_object;
-	array<float2>& prim_time;
+//	array<float2>& prim_time;
 
 	bool need_prim_time;
 
Index: intern/cycles/kernel/geom/geom_curve.h
===================================================================
--- intern/cycles/kernel/geom/geom_curve.h (revision 0)
+++ intern/cycles/kernel/geom/geom_curve.h (working copy)
@@ -231,12 +231,12 @@ ccl_device_forceinline bool bvh_cardinal_curve_intersect(KernelGlobals *kg, Inte
 {
 	const bool is_curve_primitive = (type & PRIMITIVE_CURVE);
 
-	if(!is_curve_primitive && kernel_data.bvh.use_bvh_steps) {
-		const float2 prim_time = kernel_tex_fetch(__prim_time, curveAddr);
-		if(time < prim_time.x || time > prim_time.y) {
-			return false;
-		}
-	}
+//	if(!is_curve_primitive && kernel_data.bvh.use_bvh_steps) {
+//		const float2 prim_time = kernel_tex_fetch(__prim_time, curveAddr);
+//		if(time < prim_time.x || time > prim_time.y) {
+//			return false;
+//		}
+//	}
 
 	int segment = PRIMITIVE_UNPACK_SEGMENT(type);
 	float epsilon = 0.0f;
@@ -700,12 +700,12 @@ ccl_device_forceinline bool bvh_curve_intersect(KernelGlobals *kg, Intersection
 
 	const bool is_curve_primitive = (type & PRIMITIVE_CURVE);
 
-	if(!is_curve_primitive && kernel_data.bvh.use_bvh_steps) {
-		const float2 prim_time = kernel_tex_fetch(__prim_time, curveAddr);
-		if(time < prim_time.x || time > prim_time.y) {
-			return false;
-		}
-	}
+//	if(!is_curve_primitive && kernel_data.bvh.use_bvh_steps) {
+//		const float2 prim_time = kernel_tex_fetch(__prim_time, curveAddr);
+//		if(time < prim_time.x || time > prim_time.y) {
+//			return false;
+//		}
+//	}
 
 	int segment = PRIMITIVE_UNPACK_SEGMENT(type);
 	/* curve Intersection check */
Index: intern/cycles/kernel/kernel_textures.h
===================================================================
--- intern/cycles/kernel/kernel_textures.h (revision 0)
+++ intern/cycles/kernel/kernel_textures.h (working copy)
@@ -32,7 +32,7 @@ KERNEL_TEX(uint, texture_uint, __prim_visibility)
 KERNEL_TEX(uint, texture_uint, __prim_index)
 KERNEL_TEX(uint, texture_uint, __prim_object)
 KERNEL_TEX(uint, texture_uint, __object_node)
-KERNEL_TEX(float2, texture_float2, __prim_time)
+//KERNEL_TEX(float2, texture_float2, __prim_time)
 
 /* objects */
 KERNEL_TEX(float4, texture_float4, __objects)
@@ -178,6 +178,7 @@ KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_byte4_085)
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_byte4_086)
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_byte4_087)
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_byte4_088)
+KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_byte4_089)
 
 #  else
 /* bindless textures */
Index: intern/cycles/render/mesh.cpp
===================================================================
--- intern/cycles/render/mesh.cpp (revision 0)
+++ intern/cycles/render/mesh.cpp (working copy)
@@ -1873,10 +1873,10 @@ void MeshManager::device_update_bvh(Device *device, DeviceScene *dscene, Scene *
 		dscene->prim_object.reference((uint*)&pack.prim_object[0], pack.prim_object.size());
 		device->tex_alloc("__prim_object", dscene->prim_object);
 	}
-	if(pack.prim_time.size()) {
-		dscene->prim_time.reference((float2*)&pack.prim_time[0], pack.prim_time.size());
-		device->tex_alloc("__prim_time", dscene->prim_time);
-	}
+//	if(pack.prim_time.size()) {
+//		dscene->prim_time.reference((float2*)&pack.prim_time[0], pack.prim_time.size());
+//		device->tex_alloc("__prim_time", dscene->prim_time);
+//	}
 
 	dscene->data.bvh.root = pack.root_index;
 	dscene->data.bvh.use_qbvh = scene->params.use_qbvh;
@@ -2157,7 +2157,7 @@ void MeshManager::device_free(Device *device, DeviceScene *dscene)
 	device->tex_free(dscene->prim_visibility);
 	device->tex_free(dscene->prim_index);
 	device->tex_free(dscene->prim_object);
-	device->tex_free(dscene->prim_time);
+//	device->tex_free(dscene->prim_time);
 	device->tex_free(dscene->tri_shader);
 	device->tex_free(dscene->tri_vnormal);
 	device->tex_free(dscene->tri_vindex);
@@ -2179,7 +2179,7 @@ void MeshManager::device_free(Device *device, DeviceScene *dscene)
 	dscene->prim_visibility.clear();
 	dscene->prim_index.clear();
 	dscene->prim_object.clear();
-	dscene->prim_time.clear();
+//	dscene->prim_time.clear();
 	dscene->tri_shader.clear();
 	dscene->tri_vnormal.clear();
 	dscene->tri_vindex.clear();
Index: intern/cycles/render/scene.h
===================================================================
--- intern/cycles/render/scene.h (revision 0)
+++ intern/cycles/render/scene.h (working copy)
@@ -69,7 +69,7 @@ public:
 	device_vector<uint> prim_visibility;
 	device_vector<uint> prim_index;
 	device_vector<uint> prim_object;
-	device_vector<float2> prim_time;
+//	device_vector<float2> prim_time;
 
 	/* mesh */
 	device_vector<uint> tri_shader;
